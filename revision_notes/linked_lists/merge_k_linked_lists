you have solved it in better approach, you can solve it using optimal approach
https://leetcode.com/problems/merge-k-sorted-lists/
better approach:                      optimal approach:
time_complexity=O(N*K);                Time complexity=O(klogk);{sice only heads of klists are present at a particular moment}
Better Approach:

class Solution {
public:
ListNode* merge(ListNode* list1,ListNode* list2)
{
ListNode* head=NULL,*tail=NULL;
while(list1&&list2)
{
    if(list1->val>list2->val)
    {
        if(!tail)
        {
            head=list2;
            tail=list2;
        }
        else
        {
            tail->next=list2;
            tail=tail->next;
        }
        list2=list2->next;
    }
    else
    {
        if(!tail)
        {
            head=list1;
            tail=list1;
        }
        else
        {
            tail->next=list1;
            tail=tail->next;
        }
        list1=list1->next;
    }

}
if(tail)
tail->next=list1?list1:list2;
else
{
    head=list1?list1:list2;
}
return head;
}
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if(lists.size()==0)
        return NULL;
        for(int i=1;i<lists.size();i++)
        {
            lists[i]=merge(lists[i-1],lists[i]);
        }
        return lists.back();
    }
};



Optimal approach :

 struct comparator{
    bool operator()(ListNode* list1, ListNode* list2){
        return list1->val>list2->val;
    }
 };
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        priority_queue<ListNode*, vector<ListNode*>,comparator>min_head;
        for(int i=0;i<lists.size();i++){
            if(lists[i])
                min_head.push(lists[i]);
        }
        ListNode dummy;
        ListNode*tail=&dummy;
        while(!min_head.empty()){
            ListNode* node=min_head.top();
            min_head.pop();
            tail->next=node;
            tail=tail->next;
            node=node->next;
            if(node){
                min_head.push(node);
            }
        }
        return dummy.next;
    }
};
