this problem is based on dq
  https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/description/
and the solution to that


  my initial implementation is through map and a sliding window tecnique, which was taking O(nlogn) time, which
    is somewhat inefficient, so i ahve seen the right implementation which is through dequeue, maintaining min anad max values, throughout the process














  class Solution {
public:
    int longestSubarray(vector<int>& nums, int limit) {
       // auto init = atexit([]() { ofstream("display_runtime.txt") << "0"; });
        deque<int>mind,maxd;
        int start=-1,max_len=0,n=nums.size();
       // map<int,int>check_map;
        start=0;
        for(int i=0;i<n;i++)
        {
            while(!maxd.empty()&&maxd.back()<nums[i])maxd.pop_back();
            maxd.push_back(nums[i]);
            while(!mind.empty()&&mind.back()>nums[i])mind.pop_back();
            mind.push_back(nums[i]);
           
            while(maxd.front()-mind.front()>limit)
            {
                if(nums[start]==maxd.front())maxd.pop_front();
                if(nums[start]==mind.front())mind.pop_front();
                start++;
            }
            max_len=max(max_len,i-start+1);
         /* check_map[nums[i]]++;
            if(start==-1)
            start=i;
            max_len=max(i-start,max_len);
            min_val=(check_map.begin())->first;
            max_val=(--check_map.end())->first;

            if(max_val-min_val>limit)
            {
                int temp=nums[i]==min_val?max_val:min_val;
                while(check_map.count(temp))
                {
                    check_map[nums[start]]--;
                    if(check_map[nums[start]]==0)
                    check_map.erase(nums[start]);
                    start++;          
                }             
               */
                
            }

        
      // max_len=max(max_len,n-start);
        return max_len;
    }
};
