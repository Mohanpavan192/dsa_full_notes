this is good one, i have implemented 3 approaches here go through it
https://leetcode.com/problems/word-break/

class Solution {
public:
//approach 1
bool check(string s,unordered_set<string>&dict)
{
    if(s.size()==0)
    return true;
        int n=s.size();
        string temp;
          temp.push_back(s[0]);
        for(int i=1;i<=n;i++)
        {
            if(dict.count(temp))
            {
                if(check(s.substr(i),dict))
                return true;
            }
            temp.push_back(s[i]);

        }
        return false;
}
//approach 2 base for dp
bool f(int i,string&s,unordered_set<string>&dict,int&n)
{
    if(i==s.size())
    return true;

    for(int j=i+1;j<=n;j++)
    {
        string temp=s.substr(i,j-i);
        if(dict.count(temp))
        {
            if(f(j,s,dict,n))
            return true;
        }
    }
    return false;
}
//approach 3
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> dict(wordDict.begin(), wordDict.end());
        int n=s.size(),maxlen=0;
        for(auto val:wordDict)
        {
            maxlen=max(maxlen,(int)val.size());
        }
      //return f(0,s,dict,n);
      vector<bool>dp(n+1,false);
      dp[n]=true;
      for(int i=n-1;i>=0;i--)
      {
        for(int j=i+1;j<=n;j++)
        {
           if(j-i>maxlen)
           break;
        string temp=s.substr(i,j-i);
        if(dict.count(temp))
        {
            if(dp[j])
            dp[i]=true;
            
        }
        }
      }
      return dp[0];
      //  return check(s,dict);
/*
        int n = s.size();
        vector<bool> dp(n + 1, false);
        dp[0] = true; // empty string is valid
        string temp             
        for(int i=1;i<=n;i++)
        {
           
        }
        return dp[n];*/
    }
};

